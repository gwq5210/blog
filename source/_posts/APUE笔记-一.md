title: APUE笔记(一)
date: 2017-07-12 01:22:08
tags:
---
# UNIX基础知识
所有的操作系统都为它们所运行的程序提供服务。典型的服务包括：执行新程序、打开文件、读文件、分配存储区以及获得当前时间等。

从严格意义上说，可以将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。从广义上说，操作系统包含了内核和一些其他软件，这些软件使得计算机能够发挥作用，并使计算机具有自己的特性。

我们通常将这种软件成为内核（kernel），因为它相对较小，而且位于环境的核心。

内核的接口称之为系统调用（system call）。公共函数库构建在系统调用接口之上，应用程序既可使用公共函数库，也可以使用系统调用。shell是一个特殊的应用程序， 为运行其他应用程序提供了一个接口。

系统的口令文件由7个以冒号分割的字段组成，依次是：登录名、加密口令、数字用户ID、数字组ID、注释字段、起始目录以及shell程序。目前所有已知的系统已将加密口令移到另一个文件中。

shell是一个命令解释器，它读取用户输入，然后执行命令。

<!--more-->

UNIX文件系统是目录和文件的一种层次结构，所有的目录或文件以根（root，/）为起点。

目录是一个包含目录项的文件。每个目录项都包含文件名和文件属性。目录中的各个名字称为文件名。斜线（分割路径）和空字符（标记路径名结尾）不能出现在文件名中。创建新目录会自动创建点和点点目录，分别表示当前目录和上一级目录。根目录中，点点和点相同。

以斜线开头的路径名成为绝对路径，否则称为相对路径。

每个进程都有工作目录（working directory），有时称其为当前工作目录（current working directory）。所有相对路径都从工作目录开始解释。登录时，工作目录设置为起始目录（home direcotry）。

文件描述符（file descriptor）通常是一个小的非负整数，内核用于标识一个特定进程正在访问的文件。

当运行一个新程序时，所有的shell都为其打开3个文件描述符，即标准输入，标准输出，标准错误。

函数open，write，read，lseek和close提供了不带缓冲的IO。标准IO函数为那些不带缓冲的函数提供了一个带缓冲的接口，我们无需担心如何选取最佳的缓冲区大小。

程序（program）是一个存储在磁盘上某个目录中的可执行文件。程序的执行实例被称为进程（process）。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID，它是一个非负整数。

通常一个进程只有一个线程（thread）。但进程中可以有多个线程。一个进程内的所有线程共享同一地址空间，文件描述符，栈及进程相关属性。线程也使用线程ID标识。

UNIX系统函数出错时，函数通常返回一个负值， 而且整型变量errno通常被设置为具有特定信息的值。在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno。

使用errno需要注意，如果没有出错，其值不会被任何例程清除。因此仅当函数的返回值指明出错时，才检验其值。任何函数都不会将errno值设置为0。

errno定义的错误可以分为两类，致命的和非致命的。对于致命的错误无法进行恢复动作。对于非致命的错误，有时可以进行妥善的处理。与资源相关的非致命错误包括：EAGAIN、ENFILE、ENOBUFS、ENOLCK、ENOSPC、EWOULDBLOCK，有时ENOMEM也是非致命错误。当EBUSY指明共享资源正在使用时，也可将它作为非致命性出错处理。当EINTR中断一个慢速系统调用时，可将它作为非致命性错误处理。

口令文件登录项中的用户ID是一个数值，用来标识各个不同的用户。用户ID为0的用户为根用户或超级用户。我们称超级用户的特权为超级用户特权。

组被用于将若干用户集合到一起，便于共享资源。我们用组ID来标识用户组。组文件为/etc/group，它将组ID映射为组名。

使用数值的用户ID和组ID是历史原因，它们更节省磁盘空间，在权限校验时，更加节省资源。

多数UNIX系统还允许用户属于另外一个组，我们称之为附属组（supplementary group）。

信号（signal）用来通知进程发生了某种情况。
对于信号，进程有三种方式处理：
* 忽略信号
* 按照系统默认方式处理
* 提供一个函数，信号发生时调用该函数，这被称为捕捉该信号

在进程中，我们可以调用kill函数向另一个进程发送信号，前提是我们必须是这个进程的所有者或者超级用户。

UNIX使用两种不同的时间值。一是日历时间，该值是自协调世界时（Coordinated Universal Time，UTC）1970年1月1日00:00:00这个特定时间以来所经历的秒数累计值。系统基本数据类型使用time_t保存这个时间。二是进程时间。也被称为CPU时间，用于度量进程使用的中央处理器资源。进程时间以时钟时间为单位。系统基本数据类型clock_t保存这种时间值。我们可以通过sysconf函数得到每秒的时钟滴答数。
UNIX为一个进程维护了三个进程时间：
* 时钟时间，是进程运行的时间总量，其值与系统同时运行的进程数有关。
* 用户CPU时间，是执行用户指令所用的时间量。
* 系统CPU时间，是为该进程执行内核程序所经历的时间。

我们可以简单的使用命令time获取程序的执行时间。

所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用。系统还定义了通用库函数，这些函数可能会使用一个或多个系统调用，但是它们并不是内核的入口点。

从实现者的角度，系统调用和库函数之间有根本的区别，但从用户角度看，其区别并不重要。我们应该理解，如果希望的话，我们可以替换库函数，但是系统调用通常是不能被替换的。

应用程序既可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。

# UNIX标准及实现
人们在UNIX环境编程和C程序设计语言的标准化方面做已经做了很多工作。

UNIX系统实现定了了很多幻数和常量。其中很多已经被硬编码到程序中，或用特定的技术确定。
以下两种类型的限制是必须的：
* 编译时限制，可以在头文件中定义，程序在编译时可以包含这些头文件
* 运行时限制，要求程序调用一个函数获得限制值

某些限制在给定的实现中是确定的，但在另一个实现中可能是变动的。为了解决这类问题，提供了如下三种限制：
* 编译时限制(头文件)
* 与文件或目录无关的运行时限制(sysconf函数)
* 与文件或目录有关的运行时限制(pathconf或fpathconf函数)

ISO C定义的所有编译时限制都在头文件<limits.h>中。这些限制在一个给定的系统中并不会改变。我们将会遇到的一个问题是系统是否提供带符号或无符号的字符值，可以通过其中定义的值确定。另一个ISO C的常量是FOPEN_MAX，这是具体实现保证可同时打开的标准IO流的最小个数，其在头文件<stdio.h>中定义，最小值是8。POSIX.1中的STREAM_MAX则应与其相同。头文件stdio.h中还定义了TMP_MAX，这是由tmpnam函数产生的唯一文件名的最大个数。在ISO C中虽然定义了常量FILENAME_MAX，但我们应该避免使用。POSIX.1提供了更好的代替常量NAME_MAX和PATH_MAX。

POSIX可以分为7类：
* 数值限制：LONG_BIT，SSIZE_MAX，WORD_BIT 
* 最小值
* 最大值，\_POSIX_CLOCKRES_MIN
* 运行时可以增加的值：CHARCLASS_NAME_MAX，COLL_WEIGHTS_MAX，LINE_MAX，NGROUPS_MAX，RE_DUP_MAX
* 运行时不变值
* 其他不变值
* 路径名可变值：FILESIZEBITS，LINK_MAX，MAX_CANON，MAX_INPUT,MAX_INPUT，NAME_MAX，PATH_MAX，PIPE_BUF，SYMLINK_MAX

最小值是不变的，它们不随系统改变。它们指定了这些特征最具约束性的值。一个符合POSIX.1的实现应当至少提供这样的值。为了保证移植性，严格符合标准的应用程序不应要求更大的值

不过某些最小值在实际中太小了。

运行时限制可以通过下面3个函数获得：
```
#include <unistd.h>
long sysconf(int name);
long pathconf(const char *pathname, int name);
long fpathconf(int fd, int name);
```
我们讨论这三个函数不同的返回值：
* 如果name参数并不是一个合适的常量，这三个函数都返回-1，并把errno设置为EINVAL
* 有些name返回一个变量值(大于等于0)，或者提示该值是不确定的，不确定的值通过返回-1来体现，但不改变errno的值
* \_SC_CLK_TCK返回值是每秒的时钟滴答数，用于times函数的返回值

对于后两个函数的第一个参数有很多限制。可以通过手册查询。

不确定的运行时限制：
* 路径名，可以通过PATH_MAX来获得，但是结果可能是不确定的
* 最大打开文件数，守护进程中一个常见的代码就是关闭所有打开的文件
```
#include <sys/param.h>
for (int i = 0; i < NOFILE; ++i)
{
  close(i);
}
```
但这种方式是不可移植的，所以可以通过sysconf来获取，尽可能提高移植性

如果我们需要编写可以移植的程序，这些程序可能依赖一些可选的支持的功能，我们需要一个可移植的方法来确定实现是否支持一个给定的选项

有三种处理选项的方法：
* 编译时选项定义在unistd.h中
* 与文件或目录无关的选项使用sysconf确定
* 与文件或目录有关的选项使用pathconf或fpathconf确定

对于每一个选项，有三种可能的平台支持状态。
* 如果符号常量没有定义或者定义值为-1，那么该平台在编译时不支持相应选项。但是有一种可能，在已支持该选项的新系统上运行老应用时，即使该选项在应用编译时未被支持，但如今新系统运行时检查会显示该选项已经支持
* 如果符号常量的定义值大于0，那么支持该选项
* 如果符号常量的值为0，则必须调用三个函数来确定是否支持相应的选项

如果在编译程序时，希望它只与POSIX的定义有关，而不与任何实现定义的常量冲突，那么需要定义常量\_POSIX_C_SOURCE，一旦定义了该常量，所有POSIX.1的头文件都是用此常量来排除任何实现专有的定义。可以在编译时指定该常量

头文件sys/types.h中定义了某些与实现有关的数据类型，它们被称为基本系统数据类型(primitive system data type)，它们使用C语言的typedef定义，大多使用\_t结尾，用这种方式定义了这些数据类型时，就不需要考虑因系统不同而变化的程序实现细节。

|类型|说明|
|----|----|
|clock_t|时钟滴答计数器|
|comp_t|压缩的时钟滴答|
|dev_t|设备号，主和次|
|fd_set|文件描述符集|
|fpos_t|文件位置|
|gid_t|数值组ID|
|ino_t|i节点编号|
|mode_t|文件类型，文件创建模式|
|nlink_t|目录项的链接计数|
|off_t|文件长度和偏移量，带符号的|
|pid_t|进程ID和进程组ID，带符号的|
|pthread_t|线程ID|
|ptrdiff_t|两个指针相减的结果|
|rlim_t|资源限制|
|sig_atomic_t|能原子性访问的数据类型|
|sigset_t|信号集|
|size_t|对象长度，如字符串，不带符号的|
|ssize_t|返回字节计数器的函数，带符号的|
|time_t|日历时间的秒计数器|
|uid_t|数值用户ID|
|wchar_t|能表示所有不同的字符码|

# 文件IO