title: Cpp Primer Plus读书笔记
date: 2017-07-02 21:25:04
tags:
---
# 第一章 预备知识
1. C++融合了三种不同的编程方式：
 * C语言代表的过程性语言
 * 以类为代表的面向对象于艳
 * 模板支持的泛型编程
2. 面向对象编程(OOP)强调的是数据。理念是设计与问题本质特性相对应的数据格式。
3. 泛型编程强调编程要独立于特定数据类型，即创建独立于类型的代码。
4. C++是C的超集，尽管有一些细微差别，但这种差别很小。

<!--more-->

# 第二章 开始学习C++
1. C++提供了不同于C的输入输出工具，内置的cin和cout对象，使用它们需要包含头文件iostream。
2. main函数通常被启动代码调用，启动代码是编译程序加入到程序当中的。
3. 如果main函数没有指明返回语句，则认为return 0;是返回语句。
4. C++提供两种注释的方式//(C++)或/\*\*/(C)。C99标准在C语言中加入了//注释。
5. \#include编译指令会让预处理器添加指定文件内容到程序中。
6. 不同的头文件名可被不同的程序使用。
<!--
| 头文件类型   | 约定          | 示例         | 说明                                  |
| ----------- | --------------- | -------------- | ----------------------------------- |
| C++旧式风格 | 以.h结尾       | iostream.h | C++程序可以使用                           |
| C旧式风格   | 以.h结尾       | math.h     | C,C++程序可以使用                         |
| C++新式风格 | 没有扩展名       | iostream   | C++程序可以使用，使用namespace std           |
| 转换后的C   | 加上前缀c，没有扩展名 | cmath      | C++程序可以使用，可以使用不是C的特性，如namespace std |
-->
7. C++中可以使用命名空间来避免名字冲突。可以使用using编译指令来使用命名空间中的函数或类对象。
```
using namespace std;
using std::cin;
std::cout << "Hello World!" << std::endl;
```

8. cout中，可以使用endl和"\n"表示换行符。不同的是endl确保程序继续运行前刷新输出，使用"\n"不能提供这样的保证。
```
cout << "Hello World!\n";
cout << "Hello world!" << endl;
```
9. 尽量遵循好的C++代码风格，程序会便于阅读。
10. 变量在使用前必须进行声明，通常是为了指出要存储的类型和程序对存储在这里的数据使用的名称。
11. 对于声明变量，C++的做法是尽可能在首次使用变量前声明它。
12. cout可以根据变量的类型相应的调整行为。
```
cout << 12 << "12" << endl;
printf("%d %s\n", 12, "12");
```
13. 类描述了一种数据类型的全部属性(包括可使用它执行的操作)，对象是根据这些描述创建的实体。
14. C++程序应当为程序中使用的每个函数提供原型。
15. 不要混淆函数原型和函数定义。
```
int fun();
int fun()
{
  return 0;
}
```
16. 函数可以有返回值和无返回值。无返回值的函数用void来标识。
17. 函数的格式为：
```
type functionname(argumentlist)
{
  statements
}
```
# 第三章 处理数据
1. 在程序中，为了存储信息，必须记录三个基本属性：
 * 信息将存储在哪里
 * 要存储什么值
 * 存储何种类型的信息
   声明变量恰好记录了这些信息。

2. C++变量名必须遵循如下规则，并尽量使用有意义的变量名：
 * 在名称中只能使用字母字符，数字和下划线(\_)
 * 名称的第一个字符不能是数字
 * 区分大写字符与小写字符
 * 不能将C++关键字用作名称
 * 一两个下划线或下划线和大写字母打头的名称被保留给实现(编译器及其使用的资源)使用。以一个下划线开头的名称被保留给实现，用作全局标识符。违反这一点并不会导致编译器错误，但可能会导致行为的不确定性。
 * C++对名称没有长度限制，名称中的所有字符都有意义，但有些平台有长度限制。C99标准只保证名称中的前63个字符有意义

3. 语言只能表示所有整数的子集。C++提供多种不同的整型，以便根据程序具体要求选择最合适的整型
4. C++的基本整型分别是char、short、int、long和C++ 11新增的long long，其中每种类型都有有符号版本和无符号版本
5. C++对整型提供了灵活的标准，确保整型的最小长度
 * short至少16位
 * int至少与short一样长
 * long至少32位，且至少与int一样长
 * long long至少64位，且至少与long一样长
6. 实际上，short是short int的简称，long是long int的简称
7. sizeof运算符返回类型或变量的长度，单位为字节
```
int a = 0;
cout << sizeof a << endl;	// 变量可以这样写，类型必须加括号
cout << sizeof(a) << endl;
cout << sizeof(int) << endl;
```
8. 头文件climits(limits.h)定义了符号常量来表示类型的限制
<!--
| 符号常量       | 表示                     |
| ---------- | ---------------------- |
| CHAR_BIT   | char的位数                |
| CHAR_MAX   | char的最大值               |
| CHAR_MIN   | char的最小值               |
| SCHAR_MAX  | signed char的最大值        |
| SCHAR_MIN  | signed char的最小值        |
| UCHAR_MAX  | unsigned char的最大值      |
| SHRT_MAX   | short的最大值              |
| SHRT_MIN   | short的最小值              |
| USHRT_MAX  | unsigned short的最大值     |
| INT_MAX    | int的最大值                |
| INT_MIN    | int的最小值                |
| UINT_MAX   | unsigned int的最大值       |
| LONG_MAX   | long的最大值               |
| LONG_MIN   | long的最小值               |
| ULONG_MAX  | unsigned long的最大值      |
| LLONG_MAX  | long long的最大值          |
| LLONG_MIN  | long long的最小值          |
| ULLONG_MAX | unsigned long long的最大值 |
-->
9. C++支持类似C的符号常量，其进行简单的字符串替换。C++还提供了const来定义符号常量
10. C++提供了不同于C的初始化方式：
```
int a = 0;
int b(1);
int c{2};		// C++ 11
int d = {3};	// C++ 11
int e = {};		// set to 0
int f{};		// set to 0
```
11. 无符号类型整数不能存储负数，但可以增大变量能够存储的整数的最大值
12. C++确保无符号整数溢出时会取范围另一端的值，但并不保证有符号整数超越限制(上溢和下溢出)时不出错，而这正是当前实现中最为常见的行为
13. 通常int被设置为对目标计算机而言最“自然”的长度，自然长度是只计算机处理起来效率最高的长度，如果没有非常有说服力的理由选择其他类型，则应使用int。其他根据具体取值范围来选择整数类型
14. 整型字面值(常量)是显式书写的常量。C++同C一样能以三种不同的方式来书写整数：基数为10，基数为8，基数为16。C++使用前一(两)位来标识数字常量的基数。如果第一位为1-9，则基数为10；如果第一位为0，第二位为1-7，则基数为8；如果前两位为0x或0X，则基数为16
15. C++通过后缀，长度来确定常量的类型。除非有理由(使用了后缀或值超出int存储范围)存储为其他类型，否则C++就将整数常量存储为int。
16. 后缀是放在数字常量后的字母，用于表示类型。l或L表示long，u或U表示unsigned int，ul(可以采用任何一种顺序，大小写均可)表示unsigned long(由于l看起来像1，推荐使用大写L后缀)。C++提供了用于表示long long的后缀ll或LL，还提供了用于表示unsigned long long的后缀ull，Ull，uLL，ULL
17. 对于长度，C++中，对10进制整数采用的规则与16进制和8进制稍有不同。对于不带后缀的十进制整数，将使用下面几种类型中能够存储的最小类型来表示：int、long或long long。对于不带后缀的16进制或8进制整数，将使用下面几种类型中能够存储的最小类型来表示：int、unsigned int、long、unsigned long、long long或unsigned long long
18. char类型是专为存储字符而设计的，编程语言将字符存储为数值，实际上char类型是一种整型，可以当做比short更小的整型
19. char字面值有两种表示方式：直接单引号括起来的单个字符，如'a'；使用转义字符表示的特殊字符，如'\n'
20. 与int类型不同，char在默认情况下既不是没有符号，也不是有符号。是否有符号由C++的实现来决定，但可以显式的指定char为有符号或无符号，这在把char当做数值类型是就十分重要
21. bool类型的值可以为true或false，分别表示真假。字面值true和false都可以通过提升转化为int类型。任何数字值或指针值都可以被隐式转换为bool值
22. C++中可以使用const来修改变量声明和初始化，创建一个符号常量。其被初始化后，编译器就不允许修改该常量的值。如果在定义常量是没有初始化值，则该常量的值是不确定的，且无法修改
```
const type name = value;
```
23. 浮点数可以用来表示小数，浮点数有两种表示：一是常用的标准小数点表示，如8.2等；二是E表示法，如3.45E6表示3.45与1000000相乘的结果，指数为负表示除以10的乘方。E表示法确保数字以浮点格式存储。
24. 有三种浮点类型：float、double和long double。C和C++对有效位数(数字中有意义的位数)的要求分别是：至少32位，至少48位且不少于float，long double至少和double一样多。可以从cfloat头文件获取这些类型的相关限制。
25. 默认情况下的浮点常量存储为double，如果想使用float存储，请加f或F后缀
26. 浮点数由于精度有限，在计算时可能会出现错误
27. signed char，short，int和long统称为符号整型；它们的无符号版本统称为无符号整型；C++ 11新增了long long。bool、char、wchar_t、符号整型和无符号整型统称为整型；C++ 11新增了char16_t和char32_t。float，double和long double统称为浮点型。整型和浮点型统称为算术类型
28. C++提供了5中基本算术运算：+、-、*、/、%
29. 对于除法，如果两个操作数都是整数，则结果为商的整数部分
30. 对于取模，两个操作数必须是整数，如果其中一个是负数，结果符合如下规则：(a/b)*b+a%b=a
31. 为了完成复杂的运算，需要规定运算符的优先级和结合性。\*和/的优先级高于+和-。+，-，\*，/都是从做到右结合的。从左到右的结合性意味着如果优先级相同的操作符被同时作用于同一个操作数，则首先计算左侧的操作符。从右到左亦然。
32. 对于如下表达式，程序必须在做加法前计算乘法，但并没有指出先计算哪个乘法，这取决于实现。结合性在这里不起作用，因为两个乘号没有作用到同一个操作数
```
20*5+24*6
```
33. C++自动执行多种类型转化：
    * 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换
    * 表达式中包含不同类型的类型时，C++将对值进行转换
    * 将参数传递给函数时，C++将对值进行转换
34. 初始化和赋值进行的转换有可能会丢失数值或损失精度
35. 以{}方式进行的初始化，不允许缩窄
36. 在表达式中，有两种转换：一些类型在出现时就会自动转换，有些类型在与其他类型同时出现在表达式中时将被自动转换
37. 在计算表达式时，C++将bool，char，unsigned char，signed char和short值转换为int
38. 如果short比int短，则unsigned short类型被转换成int，如果两种类型长度相同，则unsigned short转换为unsigned int，这确保转换时不会丢失数据，同样wchar_t被提升为下列类型中第一个宽度足够的类型：int，unsigned int，long或unsigned long
39. 不同类型进行计算时也会进行转化：
    * 如果有一个操作数类型为long double，则将另一个操作数转换为long double
    * 否则，如果有一个操作数类型为double，则将另一个操作数转换为double
    * 否则，如果有一个操作数类型为float，则将另一个操作数转换为float
    * 否则，说明操作数都是整型，则执行整型提升
    * 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数级别比另一个低，则转换为较高的类型
    * 如果一个操作数为有符号的，另一个操作数为无符号的，且无符号数的级别比有符号数的级别高，则将有符号数转换为无符号操作数对应的类型
    * 否则，如果有符号类型可表示无符号类型的所有可能值，则将无符号操作数转换为有符号操作数的类型
    * 否则，将两个操作数都转换为有符号类型的无符号版本
      注：传统C总是将float提升为double，即使两个操作数都是float
40. 传递参数时的类型转换通常由C++函数原型控制，然而也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对char和short(signed和unsigned)应用整型提升。另外为保持传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double
41. C++允许强制类型转换：
```
(type_name)value // C
type_name(value) // C++
```
42. 在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器把变量的类型设置成与初始值相同
