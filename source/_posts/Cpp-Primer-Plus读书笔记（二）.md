title: Cpp-Primer-Plus读书笔记（二）
date: 2017-07-09 14:47:52
tags:
---
# 循环和关系表达式
for循环为执行重复的操作提供了循序渐进的步骤。for循环的组成部分完成下面这些步骤：
* 设置初始值
* 执行测试，看看循环是否应该继续执行
* 执行循环操作
* 更新用于测试的值
```
for (initialization; test-expression; update-expression)
	body
```

C++ 语法将for看做一条语句，——虽然循环体可以包括一条或多条语句。循环只执行一次初始化，测试表达式决定循环体是否被执行，通常，这个表达式是关系表达式，即对两个值进行比较。这里可以使用任何表达式，C++将把结果强制转换为bool类型。

for循环是入口条件循环，这意味着在每轮循环之前，都将计算测试表达式得值，当测试表达式为false时，将不会执行循环体。

更新表达式在每轮循环结束时执行，此时循环体已经执行完毕。通常，它用来对跟踪循环次数的变量的值进行递增。

for循环的控制部分使用了3个表达式，任何值或任何有效的值和运算符的组合都是表达式。赋值也是一个表达式，C++将赋值表达式的值定义为左侧成员的值。

当判定表达式的值这种操作改变了内存中数据的值时，我们说表达式有副作用。判定赋值表达式的值会修改被赋值者的值。

从表达式到语句的转变很容易，只需要加分号即可。因此a=100是表达式，a=100;是语句。更准确的说，这是一条表达式语句。只要加上分号，所有的表达式都可以成为语句，但不一定有编程意义。如a+6;是合法的语句，但它没完成任何有用的工作，智能编译器甚至可能跳过这条语句

对任何表达式加上分号都可以成为语句，但是这句话反过来说就不对了。也就是说，从语句中删除分号并不一定能将它转换为表达式。对于返回语句，声明语句和for语句都不满足这种情况

C++在C的基础上添加了一项特性，要求对for循环语句做一些微妙的调整，原来的语法：
```
for (expression; expression; expression)
	statement
```
但是C++的for循环允许这样做：
```
for (int i = 0; i < 5; i++)
	printf("%d\n", i);
```
这很方便，但是不符合原来的语法，因为声明不是表达式。现在则使用下边的语句：
```
for (for-init-statement condition; expression)
	statement
```
在for-init-statement中声明变量其实还有有用的一面，这也是该知道的。这种变量只存在与for循环中，当程序离开循环，这种变量将消失

在循环中经常使用递增运算符（++）和递减运算符（--）。这两种运算符执行两种极其常用的循环操作：将循环计数器加1或减1。这两个运算符都有两种变体。前缀版本位于操作数前面，如++x；后缀版本位于操作数后面，如x++。两个版本对操作数的影响是一样的，但是影响的时间不同。粗略的讲a++意味着使用a的当前值计算表达式，然后将a的值加1；而++b的意思是先将b的值加1，然后使用新的值来计算表达式。

递增运算符和递减运算符都是漂亮的小型运算符，不过千万不要失去控制，在同一条语句对同一个值递增或递减多次。问题在于规则使用后修改和修改后使用可能会变得模糊不清。也就是说，下面这条语句在不同的系统上将生成不同的结果：
```
x = 2 * x++ * (3 - ++x);
```
对于这种语句，C++没有定义正确的行为

副作用是指在计算表达式时对某些东西进行了修改；顺序点是程序执行过程中的一个点，在这里，进入下一步之前将确保所有的副作用都进行了评估。在C++中语句中的分号就是一个顺序点，这意味着程序在处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。本章后边将讨论的有些操作也有顺序点。另外任何完整的表达式末尾都是一个顺序点。完整表达式是这样一个表达式：不是另一个更大表达式的子表达式

前缀格式和后缀格式的执行速度可能存在细微的差别，对于内置类型和当代的编译器而言，这看似不是什么问题。然而C++允许你针对类定义这些运算符，这种情况下，前缀格式的效率更高

可以将递增或递减运算符用于指针和基本变量。也可以结合使用这些运算符和\*运算符来修改指针指向的值。前缀递增、前缀递减和解除引用运算符的优先级相同，以从右到左的方式结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。\*++p的含义如下：先将++应用于pt，然后将\*应用于被递增后的pt，另一方面++\*pt意味着先取得pt指向的值，然后将这个值加1。(\*p)++，圆括号指出首先对指针解除引用，然后再进行递增。\*pt++后缀运算符++的优先级更高，这意味着将运算符应用于pt而不是\*pt。

可以使用组合赋值运算符来进行赋值：

| 操作符  | 操作数（L为左操作数，R为右操作数） |
| ---- | ------------------ |
| +=   | 将L+R赋值给L           |
| -=   | 将L-R赋值给L           |
| *=   | 将L*R赋值给L           |
| /=   | 将L/R赋值给L           |
| %=   | 将L%R赋值给L           |

C++使用花括号来构造一条复合语句（代码块）。代码块由一对花括号和它们包含的语句组成，被视为一条语句，从而满足句法的要求

复合语句还有一个有趣的特性，如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完毕该语句块后，变量将被释放。

在外部语句块中定义的变量在内部语句块中也是被定义了的。

如果在一个语句块中声明一个变量，而外部语句块中也有一个这种名称的变量，在声明位置到内部语句块结束的范围内，新的变量将隐藏旧变量，然后旧变量再次可见

逗号表达式允许将两个表达式放到C++句法只允许放一个表达式的地方。逗号并不总是逗号运算符，在声明中的逗号是分隔符

逗号表达式还有其他特性。首先，它确保先计算第一个表达式，然后计算第二个表达式，即逗号运算符是一个顺序点；其次，C++规定逗号表达式的值是第二部分的值

C++提供了6种关系运算符来对数字进行比较：

| 操作符  | 含义    |
| ---- | ----- |
| <    | 小于    |
| <=   | 小于或等于 |
| ==   | 等于    |
| >    | 大于    |
| >=   | 大于或等于 |
| !=   | 不等于   |

关系运算符的优先级比算符运算符低

不要混淆等于运算符（==）与赋值运算符（=）

C风格字符串比较，不能直接使用等于运算符进行比较，这样比较的是两个字符串的地址。对于string类字符串，可以直接使用等于运算符进行比较

while循环是没有初始化和更新部分的for循环：
```
while (test-condition)
	body
```
while也是一种入口条件循环，因此如果测试条件一开始就是false，则程序将不会执行循环体

while循环和for循环可以进行相互转换；省略for循环中的测试表达式时，测试结果将为true

在设计循环时，记住如下的原则：
* 指定循环终止的条件
* 在首次测试之前初始化条件
* 在条件再次被测试之前更新条件

在循环中，不要使用错误的分号，如：
```
int i = 0;
int cnt = 10;
while (i < cnt);   // 多了一个分号
{
  printf("%d\n", i);
}
```

C++为类型建立别名的方式有两种，一种是使用预处理器：
```
#define BYTE char
```
这样程序将使用char替换BYTE
第二种方式是使用C++的关键字typedef
```
typedef char byte; // typedef type_name alias_name;
```
使用define和使用typedef的区别在于，在声明一系列变量时，define不在有效

do while循环不同于for循环和while循环，它是出口条件循环。这意味着这种循环将首先执行循环体，然后再判定测试表达式，决定是否继续执行循环。
```
do
	body
while (test-expression);
```
三种循环各有应用场景，需要合适选择

C++新增了基于范围的for循环。这简化了一种常见的循环任务：对数组或容器的每个元素执行相同的操作，后者提供了修改元素的方法。
```
vector<int> v = {1, 2, 3};
for (int x: v)
{
  printf("%d\n", x);
}
for (int &x: v)
{
  x = 1;
}
```

cin对象支持三种不同模式的单字符输入：
```
char ch;
cin >> ch;		// 忽略空白
ch = cin.get(); // return char
cin.get(ch);	// return istream
```

可以使用文件尾条件（EOF）来表示输入的结束。检测到EOF后，cin将两位（eofbit和failbit）都设置为1，可以通过成员函数eof()来查看eofbit，如果eofbit或failbit被设置，fail函数返回true。eof和fail方法报告最近读取的结果，也就是说它们在事后报告，而不是预先报告。因此应将这两个测试放在读取后

istream提供了一个可以将istream转换为bool的函数，当cin出现在bool需要的地方时，该转换函数将被调用。如果最后一次读取成功，则转换得到的bool值为true；否则为false。因此输入可以如下：
```
while (cin.get(ch))
{
  
}
```

二维数组更像是一个表格——既有数据行又有数据列。